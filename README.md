Напишите программу, в которой определяются классы «строка», «блочная строка», «выборка», «блочная выборка», «поток вывода» и другие вспомогательные классы по желанию. Блочной строкой называется массив строк. Над блочными строками должны быть допустимы следующие операции:
• Должно быть задано правило преобразования строки в блочную строку — массив, состоящий из
одного элемента: "abc" → {"abc"}.
• «+»: при сложении двух блочных строк соответствующие массивы должны конкатенироваться. Например, {"abc"} + {"c", "b", "a"} → {"abc", "c", "b", "a"}.
• «*»: при умножении блочной строки на целое число должна получиться блочная строка, состоящая
из копий исходной: {"a", "b"} * 3 → {"a", "b", "a", "b", "a", "b"}. Аналогично с 3 * {"a",
"b"}.
• «[]»: если b — блочная строка, то b[n] должно быть вычислено как строка в массиве блочной
строки, имеющая индекс n.
• «()»: если b — блочная строка, то b(n) должно быть вычислено как символ блочной строки, имеющий индекс n. Нумерация символов блочной строки сквозная: например, символ блочной строки
{"abc", "def"} с индексом 0 равен a, символ с индексом 1 равен b, символ с индексом 3 равен d, а
символ с индексом 5 равен f.
Из приведённых правил следует, что сумма двух строк является блочной строкой — массивом из двух
элементов, а произведение строки на целое число n — блочной строкой, представляющей собой массив из
n одинаковых строк.
Выборкой называется функция, описываемая массивом из целых чисел. В результате применения этой
функции к строке должна получиться другая строка, состоящая из символов исходной строки, взятых
в порядке, задаваемым массивом – выборкой. Например, если выборка задаётся массивом {2, 0, 1} и
применяется к строке "abc", то должна получиться строка "cab". Если индекс выходит за границы строки,
то в соответствующей позиции должен быть поставлен символ ?: применение выборки {-1, 2, 3, 1} к
строке "abc" даёт строку "?c?b". Если выборка применяется к блочной строке, то используется сквозная
нумерация её символов: например, применение выборки {6, 5, 4, 3, 2, 1, 0} к блочной строке {"abc",
"def"} даст строку "?fedcba".
Блочной выборкой называется массив из выборок. Аналогично строкам должно быть задано правило
преобразования выборки в блочную выборку, операции + и *, конкатенирующие массивы блочных выборок, а также операция индексирования [], дающая выборку из массива с заданным индексом. Применение блочной выборки к блочной строке обозначается операцией () и приводит к блочной строке, каждая
составная строка которой является результатом применения соответствующей выборки из блочной выборки к исходной блочной строке. Например, в результате применения блочной выборки {{4, 3, 2, 1,
0}, {3, 5, 1}, {0}} к блочной строке {"abc", "def"} должна получиться блочная строка {"edcba",
"dfb", "a"}.
Должно быть предусмотрено задание блочных выборок, являющихся результатом последовательного
применения ранее определённых блочных выборок. Например, если f и g — блочные выборки, то выражение f(g) является блочной выборкой, применение которой к блочной строке s должно быть эквивалентно
вычислению выражения f(g(s)). Вычисления не должны быть ленивыми, суперпозиция f(g) должна
вычисляться сразу же. Например, для f = {{4, 3, 2, 1, 0}, {3, 5, 10}, {0}}, g = {{1, 2, 1}, {4,
5, 5}} суперпозиция является блочной выборкой f(g) = {{5, 4, 1, 2, 1}, {4, 5, -1}, {1}}.
Все классы должны быть описаны в отдельном пространстве имён. В этом же пространстве имён
должна находиться глобальная переменная – поток вывода блочных строк и выборок с двумя манипуляторами, один из которых выводит блочную строку в виде массива — например, в приведённом выше
виде — а другой выводит её как длинную строку — конкатенацию составляющих её строк. Вывод должен
производиться на стандартный поток вывода. Также в этом пространстве имён должен быть описан класс
«поток вывода», имеющий конструктор с одним аргументом типа std::ostream и позволяющий выводить
блочные строки и выборки в заданный поток, возможно, с указанием описанных выше манипуляторов.
